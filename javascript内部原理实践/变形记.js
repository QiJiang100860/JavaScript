window.onload = function () {
    (function() {
        for(var i=0;i<5;i++){
            console.log(i)
        }
        /*
        * 一般的for循环
        * 打印 0，1，2，3，4
        * */
    })();

    (function() {
        for(var i=0;i<5;i++){
            setTimeout(function () {
                console.log(i)
            },i*1000)
        }
        /*
        * 1.setTimeout会延迟函数执行
        * 2.当函数执行的时候此时的i值为5
        *   一开始打印一个5，每隔1s打印一个5
        * */
    })();

    (function() {
        for(var i=0;i<5;i++){
            (function (j) {
                setTimeout(function () {
                    console.log(j)
                },j*1000)
            })(i)
        }
        /*
        * for循环内有个自执行函数
        * (此处多嘴一下下)---自执行函数其实就是:<函数的声明>和<调用>合为*一体*
        * (function(){
        *
        * })()
        * 前一个括号是声明  后一个括号是调用
        *---------------------------------------------------------
        * 现在去解释上面的这个自执行函数
        * 前一个括号内声明了一个带参数(j)的函数
        * 后一个括号调用时传进去一个参数(i)
        *
        * --------------------------------------------------------
        * 现在就可以去分析了
        * 如果去掉i会发生什么呢---就是调用没有传递参数 那么j此时就是undefined
        * 那就是*立即*(立即不完全准确，只是表象，因为还是延迟函数，不过是时间参数转换成了0)打印5个undefined
        *
        * --------------------------------------------------------
        * 如果去掉j会发生什么呢---就是声明时是没有参数的（内部函数对j的引用，会抛出异常），而调用的时候传入了参数（实则没用的)
        * ---------------------------------------------------------
        * 如果两个参数都去掉呢，j引用的是谁？还是会抛异常
        *
        * ---------------------------------------------------------
        *
        * 如果在声明的时候形参写的是i而不是j,内部调用的时候也是i
        * 如果去掉i，我此处的理解是参数巧合问题。
        * */
    })();

    (function() {
        for (var i = 0; i < 5; i++) {
            setTimeout((function(i) {
                console.log(i);
            })(i), i * 1000);
        }
        /*
        * setTimeout的第一个参数是一个匿名函数或者字符串指(匿名函数的指向)，
        * 而上面这个自执行函数作为setTimeout的第一个参数，他没有返回值，即setTimeout(undefined,time);
        * 自执行函数是立即执行函数，所以会立即打印 0，1，2，3，4  （记住是：立即，立即，立即）
        * */
    })();
}